#!/usr/bin/env node\n/**\n * Compliance Linting Script\n * è–¬æ©Ÿæ³•æº–æ‹ ã®è‡ªå‹•ãƒã‚§ãƒƒã‚¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆ\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport glob from 'glob';\nimport { ComplianceChecker, type ComplianceViolation } from '../apps/web/src/lib/diagnosis/compliance-checker';\n\ninterface LintResult {\n  filePath: string;\n  violations: ComplianceViolation[];\n  score: number;\n  isCompliant: boolean;\n}\n\ninterface LintSummary {\n  totalFiles: number;\n  compliantFiles: number;\n  violationFiles: number;\n  totalViolations: number;\n  averageScore: number;\n  results: LintResult[];\n}\n\nclass ComplianceLinter {\n  private checker: ComplianceChecker;\n  private filePatterns: string[];\n  private excludePatterns: string[];\n\n  constructor() {\n    this.checker = new ComplianceChecker();\n    this.filePatterns = [\n      'apps/web/src/**/*.{ts,tsx,js,jsx}',\n      'apps/web/src/**/*.md',\n      'apps/web/public/**/*.{html,txt}',\n    ];\n    this.excludePatterns = [\n      '**/node_modules/**',\n      '**/dist/**',\n      '**/build/**',\n      '**/*.test.*',\n      '**/*.spec.*',\n      '**/coverage/**',\n      '**/.next/**',\n    ];\n  }\n\n  /**\n   * ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º\n   */\n  private extractTextFromFile(filePath: string): string[] {\n    const content = fs.readFileSync(filePath, 'utf-8');\n    const ext = path.extname(filePath).toLowerCase();\n    const texts: string[] = [];\n\n    switch (ext) {\n      case '.md':\n        // Markdownãƒ•ã‚¡ã‚¤ãƒ«ã¯ãã®ã¾ã¾\n        texts.push(content);\n        break;\n\n      case '.html':\n        // HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æŠ½å‡º\n        const htmlTextRegex = />([^<]+)</g;\n        let htmlMatch;\n        while ((htmlMatch = htmlTextRegex.exec(content)) !== null) {\n          const text = htmlMatch[1].trim();\n          if (text && text.length > 3) {\n            texts.push(text);\n          }\n        }\n        break;\n\n      case '.ts':\n      case '.tsx':\n      case '.js':\n      case '.jsx':\n        // TypeScript/JavaScriptãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’æŠ½å‡º\n        this.extractStringsFromCode(content, texts);\n        break;\n\n      case '.txt':\n        // ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¯ãã®ã¾ã¾\n        texts.push(content);\n        break;\n\n      default:\n        // ãã®ä»–ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’æŠ½å‡º\n        this.extractStringsFromCode(content, texts);\n    }\n\n    return texts;\n  }\n\n  /**\n   * ã‚³ãƒ¼ãƒ‰ã‹ã‚‰æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’æŠ½å‡º\n   */\n  private extractStringsFromCode(content: string, texts: string[]): void {\n    // æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒ»ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆï¼‰\n    const stringRegex = /['\"`]([^'\"`\\\\]*(\\\\.[^'\"`\\\\]*)*)['\"`]/g;\n    let match;\n    while ((match = stringRegex.exec(content)) !== null) {\n      const text = match[1];\n      if (text && text.length > 3 && !this.isCodeString(text)) {\n        texts.push(text);\n      }\n    }\n\n    // JSXãƒ†ã‚­ã‚¹ãƒˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„\n    const jsxTextRegex = />\\s*([^<{]+?)\\s*</g;\n    while ((match = jsxTextRegex.exec(content)) !== null) {\n      const text = match[1].trim();\n      if (text && text.length > 3 && !this.isCodeString(text)) {\n        texts.push(text);\n      }\n    }\n\n    // ã‚³ãƒ¡ãƒ³ãƒˆå†…ã®ãƒ†ã‚­ã‚¹ãƒˆ\n    const commentRegex = /\\/\\*\\*?([^*]|\\*(?!\\/))*\\*\\//g;\n    while ((match = commentRegex.exec(content)) !== null) {\n      const comment = match[0].replace(/\\/\\*\\*?|\\*\\//g, '').replace(/\\*\\s?/g, '').trim();\n      if (comment && comment.length > 10) {\n        texts.push(comment);\n      }\n    }\n\n    const lineCommentRegex = /\\/\\/\\s*(.+)$/gm;\n    while ((match = lineCommentRegex.exec(content)) !== null) {\n      const comment = match[1].trim();\n      if (comment && comment.length > 10 && !comment.startsWith('eslint') && !comment.startsWith('prettier')) {\n        texts.push(comment);\n      }\n    }\n  }\n\n  /**\n   * ã‚³ãƒ¼ãƒ‰é–¢é€£ã®æ–‡å­—åˆ—ã‹ã©ã†ã‹ã‚’åˆ¤å®š\n   */\n  private isCodeString(text: string): boolean {\n    // URLã€ãƒ‘ã‚¹ã€å¤‰æ•°åã€é–¢æ•°åãªã©ã‚’ã‚¹ã‚­ãƒƒãƒ—\n    const codePatterns = [\n      /^https?:\\/\\//,\n      /^\\//,\n      /^\\./,\n      /^[a-zA-Z_$][a-zA-Z0-9_$]*$/,\n      /^\\d+$/,\n      /^[A-Z_]+$/,\n      /className|onClick|onChange|onSubmit/,\n      /^\\s*$/,\n    ];\n\n    return codePatterns.some(pattern => pattern.test(text));\n  }\n\n  /**\n   * å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯\n   */\n  private lintFile(filePath: string): LintResult {\n    try {\n      const texts = this.extractTextFromFile(filePath);\n      const allViolations: ComplianceViolation[] = [];\n      let totalScore = 0;\n      let textCount = 0;\n\n      for (const text of texts) {\n        const result = this.checker.checkCompliance(text);\n        allViolations.push(...result.violations);\n        totalScore += result.score;\n        textCount++;\n      }\n\n      const averageScore = textCount > 0 ? totalScore / textCount : 100;\n      const isCompliant = allViolations.length === 0;\n\n      return {\n        filePath,\n        violations: allViolations,\n        score: averageScore,\n        isCompliant,\n      };\n    } catch (error) {\n      console.warn(`Warning: Could not process file ${filePath}:`, error);\n      return {\n        filePath,\n        violations: [],\n        score: 100,\n        isCompliant: true,\n      };\n    }\n  }\n\n  /**\n   * è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯\n   */\n  public async lintFiles(): Promise<LintSummary> {\n    const files: string[] = [];\n\n    // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ã„ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åé›†\n    for (const pattern of this.filePatterns) {\n      const matchedFiles = glob.sync(pattern, {\n        ignore: this.excludePatterns,\n        absolute: true,\n      });\n      files.push(...matchedFiles);\n    }\n\n    // é‡è¤‡ã‚’é™¤å»\n    const uniqueFiles = [...new Set(files)];\n\n    console.log(`Checking ${uniqueFiles.length} files for compliance violations...`);\n\n    const results: LintResult[] = [];\n    let totalScore = 0;\n    let violationCount = 0;\n\n    for (const filePath of uniqueFiles) {\n      const result = this.lintFile(filePath);\n      results.push(result);\n      totalScore += result.score;\n      if (!result.isCompliant) {\n        violationCount++;\n      }\n    }\n\n    const summary: LintSummary = {\n      totalFiles: uniqueFiles.length,\n      compliantFiles: uniqueFiles.length - violationCount,\n      violationFiles: violationCount,\n      totalViolations: results.reduce((sum, r) => sum + r.violations.length, 0),\n      averageScore: uniqueFiles.length > 0 ? totalScore / uniqueFiles.length : 100,\n      results: results.filter(r => !r.isCompliant), // é•åãŒã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿\n    };\n\n    return summary;\n  }\n\n  /**\n   * çµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã—ã¦å‡ºåŠ›\n   */\n  public formatResults(summary: LintSummary, verbose: boolean = false): string {\n    const output: string[] = [];\n\n    // ã‚µãƒãƒªãƒ¼\n    output.push('\\n=== Pharmaceutical Law Compliance Check Results ===\\n');\n    output.push(`Total files checked: ${summary.totalFiles}`);\n    output.push(`Compliant files: ${summary.compliantFiles}`);\n    output.push(`Files with violations: ${summary.violationFiles}`);\n    output.push(`Total violations: ${summary.totalViolations}`);\n    output.push(`Average compliance score: ${summary.averageScore.toFixed(1)}/100`);\n\n    if (summary.violationFiles === 0) {\n      output.push('\\nâœ… All files are compliant with pharmaceutical law!');\n      return output.join('\\n');\n    }\n\n    output.push('\\nâŒ Compliance violations found:\\n');\n\n    // é•åè©³ç´°\n    for (const result of summary.results) {\n      output.push(`ğŸ“ ${result.filePath} (Score: ${result.score.toFixed(1)}/100)`);\n      \n      // é‡è¦åº¦åˆ¥ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–\n      const highViolations = result.violations.filter(v => v.severity === 'high');\n      const mediumViolations = result.violations.filter(v => v.severity === 'medium');\n      const lowViolations = result.violations.filter(v => v.severity === 'low');\n\n      if (highViolations.length > 0) {\n        output.push('  ğŸš¨ High severity violations:');\n        for (const violation of highViolations) {\n          output.push(`    - \"${violation.term}\" at position ${violation.position}`);\n          output.push(`      ${violation.description}`);\n          if (violation.alternatives && violation.alternatives.length > 0) {\n            output.push(`      Suggested alternatives: ${violation.alternatives.join(', ')}`);\n          }\n          if (verbose) {\n            output.push(`      Context: \"${violation.context}\"`);\n          }\n        }\n      }\n\n      if (mediumViolations.length > 0) {\n        output.push('  âš ï¸  Medium severity violations:');\n        for (const violation of mediumViolations) {\n          output.push(`    - \"${violation.term}\" at position ${violation.position}`);\n          output.push(`      ${violation.description}`);\n          if (violation.alternatives && violation.alternatives.length > 0) {\n            output.push(`      Suggested alternatives: ${violation.alternatives.join(', ')}`);\n          }\n        }\n      }\n\n      if (lowViolations.length > 0 && verbose) {\n        output.push('  â„¹ï¸  Low severity violations:');\n        for (const violation of lowViolations) {\n          output.push(`    - \"${violation.term}\" at position ${violation.position}`);\n          output.push(`      ${violation.description}`);\n        }\n      }\n\n      output.push('');\n    }\n\n    // æ”¹å–„ææ¡ˆ\n    output.push('ğŸ’¡ Improvement suggestions:');\n    const allViolations = summary.results.flatMap(r => r.violations);\n    const categoryCount = new Map<string, number>();\n    \n    allViolations.forEach(violation => {\n      const count = categoryCount.get(violation.category) || 0;\n      categoryCount.set(violation.category, count + 1);\n    });\n\n    if (categoryCount.get('medical_effect')) {\n      output.push('  - Replace medical effect claims with \"support\", \"maintain\", or \"supplement\" expressions');\n    }\n    if (categoryCount.get('disease')) {\n      output.push('  - Avoid disease names and use \"health maintenance\" or \"nutritional support\" instead');\n    }\n    if (categoryCount.get('guarantee')) {\n      output.push('  - Remove guarantee expressions and use \"may help\" or \"potential\" instead');\n    }\n\n    return output.join('\\n');\n  }\n}\n\n/**\n * ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•°\n */\nasync function main() {\n  const args = process.argv.slice(2);\n  const verbose = args.includes('--verbose') || args.includes('-v');\n  const jsonOutput = args.includes('--json');\n  const exitOnViolation = args.includes('--strict');\n\n  const linter = new ComplianceLinter();\n  \n  try {\n    const summary = await linter.lintFiles();\n\n    if (jsonOutput) {\n      console.log(JSON.stringify(summary, null, 2));\n    } else {\n      console.log(linter.formatResults(summary, verbose));\n    }\n\n    // é•åãŒã‚ã‚‹å ´åˆã®çµ‚äº†ã‚³ãƒ¼ãƒ‰\n    if (exitOnViolation && summary.violationFiles > 0) {\n      process.exit(1);\n    }\n  } catch (error) {\n    console.error('Error during compliance check:', error);\n    process.exit(1);\n  }\n}\n\n// ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨ã—ã¦å®Ÿè¡Œã•ã‚ŒãŸå ´åˆ\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nexport { ComplianceLinter };\n